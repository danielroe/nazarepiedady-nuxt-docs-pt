---
navigation.icon: uil:channel
description: A Nuxt fornece fun√ß√µes de composi√ß√£o para manipular a requisi√ß√£o de dados dentro da tua aplica√ß√£o.
---

# Requisi√ß√£o de Dados

A Nuxt fornece as fun√ß√µes `useFetch`, `useLazyFetch`, `useAsyncData` e `useLazyAsyncData` para manipular a requisi√ß√£o de dados dentro da tua aplica√ß√£o.

::alert{icon=üëâ}
**As fun√ß√µes `useFetch`, `useLazyFetch`, `useAsyncData` e `useLazyAsyncData` apenas funcionam durante o `setup` ou `Gatilhos do Ciclo de Vida`**.
::

## `useFetch`

Dentro das tuas p√°ginas, componentes e extens√µes podes usar a `useFetch` para ir buscar universalmente a partir de qualquer URL.

Esta fun√ß√£o de composi√ß√£o fornece um embrulhador conveniente em torno da `useAsyncData` e `$fetch`. Ela gera automaticamente uma chave baseada na URL e op√ß√µes de busca, fornece sugest√µes de tipo para URL da requisi√ß√£o baseada nas rotas do servidor, e infere o tipo da resposta da API.

::ReadMore{link="/docs/api/composables/use-fetch"}
::

### Exemplo

```vue [app.vue]
<script setup>
const { data: count } = await useFetch('/api/count')
</script>

<template>
  Page visits: {{ count }}
</template>
```

::LinkExample{link="/docs/examples/composables/use-fetch"}
::

## `useLazyFetch`

Esta fun√ß√£o de composi√ß√£o comporta-se de maneira id√™ntica √† `useFetch` com a op√ß√£o `lazy: true` definida. Em outras palavras, a fun√ß√£o ass√≠ncrona n√£o bloqueia a navega√ß√£o. Isto significa que precisar√°s de lidar com a situa√ß√£o onde o dado √© `null` (ou seja qual for o valor que forneceste em uma fun√ß√£o de f√°brica `default` personalizada).

::ReadMore{link="/docs/api/composables/use-lazy-fetch"}
::

### Exemplo

```vue
<template>
  <!-- precisar√°s de lidar com um estado de carregamento -->
  <div v-if="pending">
    Loading ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- fazer alguma coisa -->
    </div>
  </div>
</template>

<script setup>
const { pending, data: posts } = useLazyFetch('/api/posts')
watch(posts, (newPosts) => {
  // J√° que `posts` come√ßa `null`, n√£o ter√°s acesso
  // ao seu conte√∫do imediatamente, mas podes observ√°-lo.
})
</script>
```

## `useAsyncData`

Dentro das tuas p√°ginas, componentes, e extens√µes podes usar `useAsyncData` para teres acesso √† dados que resolve de maneira ass√≠ncrona.

::alert
Tu podes estar a perguntar para ti mesmo: qual √© a diferen√ßa entre `useFetch` e `useAsyncData`?

Em resumo, a `useFetch` recebe uma URL e recebe aquele dado, ao passo que a `useAsyncData` pode ter l√≥gico mais complexa. A `useFetch(url)` √© quase equivalente √† `useAsyncData(url, () => $fetch(url))` - √© o a√ß√∫car da experi√™ncia de programa√ß√£o para o caso de uso mais comum.
::

::ReadMore{link="/docs/api/composables/use-async-data"}
::

### Exemplo

```ts [server/api/count.ts]
let counter = 0
export default defineEventHandler(() => {
  counter++
  return counter
})
```

```vue [app.vue]
<script setup>
const { data } = await useAsyncData('count', () => $fetch('/api/count'))
</script>

<template>
  Page visits: {{ data }}
</template>
```

::LinkExample{link="/docs/examples/composables/use-async-data"}
::

## `useLazyAsyncData`

Esta fun√ß√£o de composi√ß√£o comporta-se de maneira id√™ntica √† `useAsyncData` com a op√ß√£o `lazy: true` definida. Em outras palavras, a fun√ß√£o ass√≠ncrona n√£o bloqueia a navega√ß√£o. Isto significa que precisar√°s de lidar com a situa√ß√£o onde o dado √© `null` (ou seja qual for o valor que tiveres fornecido em uma fun√ß√£o de f√°brica `default` personalizada).

::ReadMore{link="/docs/api/composables/use-lazy-async-data"}
::

### Exemplo

```vue
<template>
  <div>
    {{ pending ? 'Loading' : count }}
  </div>
</template>

<script setup>
const { pending, data: count } = useLazyAsyncData('count', () => $fetch('/api/count'))
watch(count, (newCount) => {
  // J√° que `count` come√ßa `null`, n√£o ter√°s acesso
  // ao seu conte√∫do imediatamente, mas podes observ√°-lo.
})
</script>
```

## Atualizando os Dados

Algumas vezes ao longo do curso da visita de p√°gina do teu utilizador, talvez precises atualizar os dados carregados a partir da API. Isto pode acontecer se o utilizador escolher paginar, filtrar resultados, pesquisar, etc.

Tu podes certificar-te de que o m√©todo `refresh()` retornado da fun√ß√£o de composi√ß√£o `useFetch()` para atualizar os dados com par√¢metros de consulta diferentes:

```vue
<script setup>
const page = ref(1);

const { data: users, pending, refresh, error } = await useFetch(() => `users?page=${page.value}&take=6`, { baseURL: config.API_BASE_URL }
);

function previous() {
  page.value--;
  refresh();
}

function next() {
  page.value++;
  refresh();
}
</script>
```

A chave para fazer isto funcionar √© chamar o m√©todo `refresh()` retornado da fun√ß√£o de composi√ß√£o `useFetch()` quando um par√¢metro de consulta tiver mudado.

Por padr√£o, a `refresh` cancelar√£o quaisquer requisi√ß√µes pendentes; o resultado delas n√£o atualizar√° os dados ou estado pendente. Quaisquer promessas esperadas anteriormente n√£o resolver√£o at√© esta nova requisi√ß√£o resolver. Tu podes evitar este comportamento definindo a op√ß√£o `dedupe`, que retornar√° a promessa para a requisi√ß√£o em execu√ß√£o atualmente, se houver uma:

```js
refresh({ dedupe: true })
```

### `refreshNuxtData`

Invalida o armazenamento de consulta imediata de `useAsyncData`, `useLazyAsyncData`, `useFetch`, e `useLazyFetch` e aciona a atualiza√ß√£o.

Este m√©todo √© √∫til se quiseres atualizar todas as requisi√ß√£o de dados para uma p√°gina atual.

::ReadMore{link="/docs/api/utils/refresh-nuxt-data"}
::

#### Exemplo

```vue
<template>
  <div>
    {{ pending ? 'Loading' : count }}
  </div>
  <button @click="refresh">Refresh</button>
</template>

<script setup>
const { pending, data: count } = useLazyAsyncData('count', () => $fetch('/api/count'))

const refresh = () => refreshNuxtData('count')
</script>
```

### `clearNuxtData`

Elimina os dados armazenados para consulta imediata, estados de erro e promessas pendentes de `useAsyncData` e `useFetch`.

Este m√©todo √© √∫til se quiseres invalidar a requisi√ß√£o de dados para uma outra p√°gina.

::ReadMore{link="/docs/api/utils/clear-nuxt-data"}
::

## Suporte da API de Op√ß√µes

A Nuxt 3 fornece uma maneira de realizar a requisi√ß√£o de `asyncData` dentro da API de Op√ß√µes. Tu deves envolver a tua defini√ß√£o de componente dentro de `defineNuxtComponent` para isto funcionar:

```vue
<script>
export default defineNuxtComponent({
  fetchKey: 'hello',
  async asyncData () {
    return {
      hello: await $fetch('/api/hello')
    }
  }
})
</script>
```

::Alert
O uso de `<script setup lang="ts">` √© a maneira recomendada de declarar os componentes de Vue na Nuxt 3.
::

::ReadMore{link="/docs/api/utils/define-nuxt-component"}
::

## `fetch` e `$fetch` Isomorfo

Quando chamamos `fetch` no navegador, os cabe√ßalhos do utilizador como `cookie` ser√£o diretamente enviados para a API. Mas durante a interpreta√ß√£o no lado do servidor, j√° que a requisi√ß√£o de `fetch` ocorre 'internamente' dentro do servidor, ela n√£o inclui os cookies do navegador do utilizador, nem passam os cookies da resposta da requisi√ß√£o.

::ReadMore{link="/docs/api/utils/dollarfetch"}
::

### Exemplo: Passar os Cabe√ßalhos do Cliente para a API

N√≥s podemos usar [`useRequestHeaders`](/docs/api/composables/use-request-headers) para acessar e delegar os cookies para a API a partir do lado do servidor.

O exemplo abaixo adiciona os cabe√ßalhos de requisi√ß√£o para uma chamada de `$fetch` isomorfa para assegurar que o destino da API tem acesso ao mesmo cabe√ßalho `cookie` originalmente enviado pelo utilizador:

```vue
<script setup>
const headers = useRequestHeaders(['cookie'])
const { data } = await useFetch('/api/me', { headers })
</script>
```

::alert{type="warning"}
Tenha muito cuidado antes de delegar os cabe√ßalhos para uma API externa e apenas inclua os cabe√ßalhos que precisas. Nem todos os cabe√ßalhos s√£o seguros para serem contornados e podem introduzir comportamento indesejado. C√° est√° uma lista de cabe√ßalhos comuns que N√ÉO s√£o delegados:

* `host`, `accept`
* `content-length`, `content-md5`, `content-type`
* `x-forwarded-host`, `x-forwarded-port`, `x-forwarded-proto`
* `cf-connecting-ip`, `cf-ray`
::

### Exemplo: Passar os Cookies das Chamadas de API do Lado do Servidor na Resposta de SSR

Se quiseres passar ou delegar os cookies em outra dire√ß√£o, de um requisi√ß√£o interna de volta para o cliente, precisar√°s de manipular isto tu mesmo:

```ts [composables/fetch.ts]
export const fetchWithCookie = async (event: H3Event, url: string) => {
  const res = await $fetch.raw(url)
  const cookies = (res.headers.get('set-cookie') || '').split(',')
  for (const cookie of cookies) {
    appendHeader(event, 'set-cookie', cookie)
  }
  return res._data
}
```

```vue
<script setup lang="ts">
// Esta fun√ß√£o de composi√ß√£o passar√° automaticamente os cookies para o cliente
const event = useRequestEvent()
const result = await fetchWithCookie(event, '/api/with-cookie')
onMounted(() => console.log(document.cookie))
</script>
```

## Boas Pr√°ticas

Os dados retornados por estas fun√ß√µes de composi√ß√£o ser√£o armazenados dentro da carga da p√°gina. Isto significa que toda chave retornada que n√£o √© usada no teu componente ser√£o adicionada √† carga.

::alert{icon=üëâ}
**N√≥s recomendamos fortemente que apenas seleciones as chaves que usar√°s no teu componente.**
::

Suponha que `/api/mountains/everest` retorna o seguinte objeto:

```json
{
  "title": "Mount Everest",
  "description": "Mount Everest is Earth's highest mountain above sea level, located in the Mahalangur Himal sub-range of the Himalayas. The China‚ÄìNepal border runs across its summit point",
  "height": "8,848 m",
  "countries": [
    "China",
    "Nepal"
  ],
  "continent": "Asia",
  "image": "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Everest_kalapatthar.jpg/600px-Everest_kalapatthar.jpg"
}
```

Se planeias apenas usar `title` e `description` no teu componente, podes selecionar as chaves acorrentando o resultado da op√ß√£o `$fetch` ou `pick`:

```vue
<script setup>
const { data: mountain } = await useFetch('/api/mountains/everest', { pick: ['title', 'description'] })
</script>

<template>
  <h1>{{ mountain.title }}</h1>
  <p>{{ mountain.description }}</p>
</template>
```

## Usando a Configura√ß√£o Ass√≠ncrona

Se estiveres a usar `async setup()`, a inst√¢ncia do componente atual ser√° perdida depois do primeiro `await`. (Isto √© uma limita√ß√£o da Vue 3.) Se quiseres usar v√°rias opera√ß√µes ass√≠ncronas, tais como v√°rias chamadas para `useFetch`, precisar√°s de usar o `<script setup>` ou esper√°-los ao mesmo tempo no final da configura√ß√£o.

::alert{icon=üëâ}
O uso de `<script setup>` √© recomendado, j√° este remove a limita√ß√£o de usar a espera de alto n√≠vel. [Leia mais](https://vuejs.org/api/sfc-script-setup.html#top-level-await).
::

```vue
<script>
export default defineComponent({
  async setup() {
    const [{ data: organization }, { data: repos }] = await Promise.all([
      useFetch(`https://api.github.com/orgs/nuxt`),
      useFetch(`https://api.github.com/orgs/nuxt/repos`)
    ])

    return {
      organization,
      repos
    }
  }
})
</script>

<template>
  <header>
    <h1>{{ organization.login }}</h1>
    <p>{{ organization.description }}</p>
  </header>
</template>
```

## Directly Calling an API Endpoint

There are instances where you may need to directly call the API. Nuxt 3 provides a globally available `$fetch` method using [unjs/ofetch](https://github.com/unjs/ofetch) (in addition to `fetch`)
with the same API as the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).

Using `$fetch` has a number of benefits, including:

It will handle 'smartly' making direct API calls if it's running on the server, or making a client-side call to your API if it's running on the client. (It can also handle calling third-party APIs.)

Plus, it comes with convenience features including automatically parsing responses and stringifying data.
