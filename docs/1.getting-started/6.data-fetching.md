---
navigation.icon: uil:channel
description: A Nuxt fornece fun√ß√µes de composi√ß√£o para manipular a requisi√ß√£o de dados dentro da tua aplica√ß√£o.
---

# Requisi√ß√£o de Dados

A Nuxt fornece as fun√ß√µes `useFetch`, `useLazyFetch`, `useAsyncData` e `useLazyAsyncData` para manipular a requisi√ß√£o de dados dentro da tua aplica√ß√£o.

::alert{icon=üëâ}
**As fun√ß√µes `useFetch`, `useLazyFetch`, `useAsyncData` e `useLazyAsyncData` apenas funcionam durante o `setup` ou `Gatilhos do Ciclo de Vida`**.
::

## `useFetch`

Dentro das tuas p√°ginas, componentes e extens√µes podes usar a `useFetch` para ir buscar universalmente a partir de qualquer URL.

Esta fun√ß√£o de composi√ß√£o fornece um embrulhador conveniente em torno da `useAsyncData` e `$fetch`. Ela gera automaticamente uma chave baseada na URL e op√ß√µes de busca, fornece sugest√µes de tipo para URL da requisi√ß√£o baseada nas rotas do servidor, e infere o tipo da resposta da API.

::ReadMore{link="/docs/api/composables/use-fetch"}
::

### Exemplo

```vue [app.vue]
<script setup>
const { data: count } = await useFetch('/api/count')
</script>

<template>
  Page visits: {{ count }}
</template>
```

::LinkExample{link="/docs/examples/composables/use-fetch"}
::

## `useLazyFetch`

Esta fun√ß√£o de composi√ß√£o comporta-se de maneira id√™ntica √† `useFetch` com a op√ß√£o `lazy: true` definida. Em outras palavras, a fun√ß√£o ass√≠ncrona n√£o bloqueia a navega√ß√£o. Isto significa que precisar√°s de lidar com a situa√ß√£o onde o dado √© `null` (ou seja qual for o valor que forneceste em uma fun√ß√£o de f√°brica `default` personalizada).

::ReadMore{link="/docs/api/composables/use-lazy-fetch"}
::

### Exemplo

```vue
<template>
  <!-- precisar√°s de lidar com um estado de carregamento -->
  <div v-if="pending">
    Loading ...
  </div>
  <div v-else>
    <div v-for="post in posts">
      <!-- fazer alguma coisa -->
    </div>
  </div>
</template>

<script setup>
const { pending, data: posts } = useLazyFetch('/api/posts')
watch(posts, (newPosts) => {
  // J√° que `posts` come√ßa `null`, n√£o ter√°s acesso
  // ao seu conte√∫do imediatamente, mas podes observ√°-lo.
})
</script>
```

## `useAsyncData`

Dentro das tuas p√°ginas, componentes, e extens√µes podes usar `useAsyncData` para teres acesso √† dados que resolve de maneira ass√≠ncrona.

::alert
Tu podes estar a perguntar para ti mesmo: qual √© a diferen√ßa entre `useFetch` e `useAsyncData`?

Em resumo, a `useFetch` recebe uma URL e recebe aquele dado, ao passo que a `useAsyncData` pode ter l√≥gico mais complexa. A `useFetch(url)` √© quase equivalente √† `useAsyncData(url, () => $fetch(url))` - √© o a√ß√∫car da experi√™ncia de programa√ß√£o para o caso de uso mais comum.
::

::ReadMore{link="/docs/api/composables/use-async-data"}
::

### Exemplo

```ts [server/api/count.ts]
let counter = 0
export default defineEventHandler(() => {
  counter++
  return counter
})
```

```vue [app.vue]
<script setup>
const { data } = await useAsyncData('count', () => $fetch('/api/count'))
</script>

<template>
  Page visits: {{ data }}
</template>
```

::LinkExample{link="/docs/examples/composables/use-async-data"}
::

## `useLazyAsyncData`

Esta fun√ß√£o de composi√ß√£o comporta-se de maneira id√™ntica √† `useAsyncData` com a op√ß√£o `lazy: true` definida. Em outras palavras, a fun√ß√£o ass√≠ncrona n√£o bloqueia a navega√ß√£o. Isto significa que precisar√°s de lidar com a situa√ß√£o onde o dado √© `null` (ou seja qual for o valor que tiveres fornecido em uma fun√ß√£o de f√°brica `default` personalizada).

::ReadMore{link="/docs/api/composables/use-lazy-async-data"}
::

### Exemplo

```vue
<template>
  <div>
    {{ pending ? 'Loading' : count }}
  </div>
</template>

<script setup>
const { pending, data: count } = useLazyAsyncData('count', () => $fetch('/api/count'))
watch(count, (newCount) => {
  // J√° que `count` come√ßa `null`, n√£o ter√°s acesso
  // ao seu conte√∫do imediatamente, mas podes observ√°-lo.
})
</script>
```

## Atualizando os Dados

Algumas vezes ao longo do curso da visita de p√°gina do teu utilizador, talvez precises atualizar os dados carregados a partir da API. Isto pode acontecer se o utilizador escolher paginar, filtrar resultados, pesquisar, etc.

Tu podes certificar-te de que o m√©todo `refresh()` retornado da fun√ß√£o de composi√ß√£o `useFetch()` para atualizar os dados com par√¢metros de consulta diferentes:

```vue
<script setup>
const page = ref(1);

const { data: users, pending, refresh, error } = await useFetch(() => `users?page=${page.value}&take=6`, { baseURL: config.API_BASE_URL }
);

function previous() {
  page.value--;
  refresh();
}

function next() {
  page.value++;
  refresh();
}
</script>
```

A chave para fazer isto funcionar √© chamar o m√©todo `refresh()` retornado da fun√ß√£o de composi√ß√£o `useFetch()` quando um par√¢metro de consulta tiver mudado.

Por padr√£o, a `refresh` cancelar√£o quaisquer requisi√ß√µes pendentes; o resultado delas n√£o atualizar√° os dados ou estado pendente. Quaisquer promessas esperadas anteriormente n√£o resolver√£o at√© esta nova requisi√ß√£o resolver. Tu podes evitar este comportamento definindo a op√ß√£o `dedupe`, que retornar√° a promessa para a requisi√ß√£o em execu√ß√£o atualmente, se houver uma:

```js
refresh({ dedupe: true })
```

### `refreshNuxtData`

Invalida o armazenamento de consulta imediata de `useAsyncData`, `useLazyAsyncData`, `useFetch`, e `useLazyFetch` e aciona a atualiza√ß√£o.

Este m√©todo √© √∫til se quiseres atualizar todas as requisi√ß√£o de dados para uma p√°gina atual.

::ReadMore{link="/docs/api/utils/refresh-nuxt-data"}
::

#### Exemplo

```vue
<template>
  <div>
    {{ pending ? 'Loading' : count }}
  </div>
  <button @click="refresh">Refresh</button>
</template>

<script setup>
const { pending, data: count } = useLazyAsyncData('count', () => $fetch('/api/count'))

const refresh = () => refreshNuxtData('count')
</script>
```

### `clearNuxtData`

Delete cached data, error status and pending promises of `useAsyncData` and `useFetch`.

This method is useful if you want to invalidate the data fetching for another page.

::ReadMore{link="/docs/api/utils/clear-nuxt-data"}
::

## Options API support

Nuxt 3 provides a way to perform `asyncData` fetching within the Options API. You must wrap your component definition within `defineNuxtComponent` for this to work.

```vue
<script>
export default defineNuxtComponent({
  fetchKey: 'hello',
  async asyncData () {
    return {
      hello: await $fetch('/api/hello')
    }
  }
})
</script>
```

::Alert
Using `<script setup lang="ts">` is the recommended way of declaring Vue components in Nuxt 3.
::

::ReadMore{link="/docs/api/utils/define-nuxt-component"}
::

## Isomorphic `fetch` and `$fetch`

When we call `fetch` in the browser, user headers like `cookie` will be directly sent to the API. But during server-side-rendering, since the `fetch` request takes place 'internally' within the server, it doesn't include the user's browser cookies, nor does it pass on cookies from the fetch response.

::ReadMore{link="/docs/api/utils/dollarfetch"}
::

### Example: Pass Client Headers to the API

We can use [`useRequestHeaders`](/docs/api/composables/use-request-headers) to access and proxy cookies to the API from server-side.

The example below adds the request headers to an isomorphic `$fetch` call to ensure that the API endpoint has access to the same `cookie` header originally sent by the user.

```vue
<script setup>
const headers = useRequestHeaders(['cookie'])
const { data } = await useFetch('/api/me', { headers })
</script>
```

::alert{type="warning"}
Be very careful before proxying headers to an external API and just include headers that you need. Not all headers are safe to be bypassed and might introduce unwanted behavior. Here is a list of common headers that are NOT to be proxied:

* `host`, `accept`
* `content-length`, `content-md5`, `content-type`
* `x-forwarded-host`, `x-forwarded-port`, `x-forwarded-proto`
* `cf-connecting-ip`, `cf-ray`
::

### Example: Pass Cookies From Server-side API Calls on SSR Response

 If you want to pass on/proxy cookies in the other direction, from an internal request back to the client, you will need to handle this yourself.

```ts [composables/fetch.ts]
export const fetchWithCookie = async (event: H3Event, url: string) => {
  const res = await $fetch.raw(url)
  const cookies = (res.headers.get('set-cookie') || '').split(',')
  for (const cookie of cookies) {
    appendHeader(event, 'set-cookie', cookie)
  }
  return res._data
}
```

```vue
<script setup lang="ts">
// This composable will automatically pass cookies to the client
const event = useRequestEvent()
const result = await fetchWithCookie(event, '/api/with-cookie')
onMounted(() => console.log(document.cookie))
</script>
```

## Best Practices

The data returned by these composables will be stored inside the page payload. This means that every key returned that is not used in your component will be added to the payload.

::alert{icon=üëâ}
**We strongly recommend you only select the keys that you will use in your component.**
::

Imagine that `/api/mountains/everest` returns the following object:

```json
{
  "title": "Mount Everest",
  "description": "Mount Everest is Earth's highest mountain above sea level, located in the Mahalangur Himal sub-range of the Himalayas. The China‚ÄìNepal border runs across its summit point",
  "height": "8,848 m",
  "countries": [
    "China",
    "Nepal"
  ],
  "continent": "Asia",
  "image": "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Everest_kalapatthar.jpg/600px-Everest_kalapatthar.jpg"
}
```

If you plan to only use `title` and `description` in your component, you can select the keys by chaining the result of `$fetch` or `pick` option:

```vue
<script setup>
const { data: mountain } = await useFetch('/api/mountains/everest', { pick: ['title', 'description'] })
</script>

<template>
  <h1>{{ mountain.title }}</h1>
  <p>{{ mountain.description }}</p>
</template>
```

## Using Async Setup

If you are using `async setup()`, the current component instance will be lost after the first `await`. (This is a Vue 3 limitation.) If you want to use multiple async operations, such as multiple calls to `useFetch`, you will need to use `<script setup>` or await them together at the end of setup.

::alert{icon=üëâ}
Using `<script setup>` is recommended, as it removes the limitation of using top-level await. [Read more](https://vuejs.org/api/sfc-script-setup.html#top-level-await)
::

```vue
<script>
export default defineComponent({
  async setup() {
    const [{ data: organization }, { data: repos }] = await Promise.all([
      useFetch(`https://api.github.com/orgs/nuxt`),
      useFetch(`https://api.github.com/orgs/nuxt/repos`)
    ])

    return {
      organization,
      repos
    }
  }
})
</script>

<template>
  <header>
    <h1>{{ organization.login }}</h1>
    <p>{{ organization.description }}</p>
  </header>
</template>
```

## Directly Calling an API Endpoint

There are instances where you may need to directly call the API. Nuxt 3 provides a globally available `$fetch` method using [unjs/ofetch](https://github.com/unjs/ofetch) (in addition to `fetch`)
with the same API as the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).

Using `$fetch` has a number of benefits, including:

It will handle 'smartly' making direct API calls if it's running on the server, or making a client-side call to your API if it's running on the client. (It can also handle calling third-party APIs.)

Plus, it comes with convenience features including automatically parsing responses and stringifying data.
